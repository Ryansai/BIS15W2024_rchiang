---
title: "BIS15L_AI_class"
author: "Your Name"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overview
Today, we're exploring how AI can aid in writing, comprehending and troubleshooting our R code. AI is a very valuable tool, but it's important not to rely on it entirely. Building a strong R foundation is still important. These AI tools are not perfect and can be inaccurate solutions. In addition these tools can't read our minds, so understanding R helps us generate better prompts to get better responses. In short, AI should be used as a tool, not a crutch. Additionally, do not forget about other useful resources like Stack Overflow/Exchange, online tutorials, and GitHub issues pages for learning and troubleshooting. Let's combine AI with traditional methods to master R effectively.

This overview isn't exhaustive of all possible AI tools for R coding, but I believe it is a good start and covers everything you need.


**Make sure to enable Github Copilot in RStudio.**
Go to Tools -> Global Options -> Copilot -> Enable Git

## Learning Goals: 
*At the end of this exercise, you will be able to:*  
1. Explain what AI is and what AI tools can be used for R.
2. Enable Github Copilot in RStudio.
3. Use Copilot/ChatGPT to write code in RStudio.
4. Use Copilot/ChatGPT for troubleshooting code in RStudio.


## Exploration Questions:
Lets get some get a feel for what copilot (or ChatGPT) does, use Github Copilot to autocomplete the questions below. You can alternatively paste the questions in ChatGPT or Microsoft Copilot.
1. What is AI?
Artificial Intelligence (AI) means making machines capable of doing tasks that normally require human intelligence, like recognizing speech, understanding languages, or making decisions. There are different types of AI: narrow AI, which is good at specific tasks, and general AI, which can handle many different tasks like a human. AI uses technologies like machine learning and deep learning. It's used in many fields, from healthcare to finance, and has the potential to make our lives easier and better.

2. What is ChatGPT?

ChatGPT is an artificial intelligence developed by OpenAI known for its conversational abilities. It's part of a family of AI models called Generative Pre-trained Transformers, or GPT for short. ChatGPT has been trained on a massive dataset of text from various sources and is capable of understanding and generating human-like responses to a wide range of prompts and questions. It's often used in chatbots, virtual assistants, and other applications where natural language understanding and generation are important.
3. What is Github Copilot?
GitHub Copilot is an AI-powered code completion tool developed by GitHub in collaboration with OpenAI. It integrates with popular code editors like Visual Studio Code and provides suggestions for code snippets, comments, and even whole functions based on the context of what you're working on. It's built on OpenAI's GPT (Generative Pre-trained Transformer) technology, which allows it to understand and generate code based on the patterns it learns from a vast amount of publicly available code repositories. GitHub Copilot aims to improve developer productivity by helping to automate repetitive coding tasks and providing helpful suggestions during the coding process.
4. What is Biophysics
Biophysics is a branch of science that combines principles of physics with those of biology to study biological systems. It focuses on understanding the physical processes and mechanisms that govern living organisms, ranging from the molecular and cellular levels to whole organisms and ecosystems.

Biophysicists use tools and techniques from physics, mathematics, chemistry, and biology to investigate various biological phenomena. These phenomena include the structure and function of biomolecules such as proteins, DNA, and membranes, as well as processes like cell signaling, membrane transport, and nerve impulse transmission.

The field of biophysics encompasses a wide range of research areas, including molecular biophysics, structural biology, computational biology, biomechanics, bioinformatics, and systems biology. Biophysicists often work at the interface of different scientific disciplines to address complex questions about living systems and contribute to advancements in areas such as medicine, biotechnology, and environmental science.
## Load the libraries  
```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(janitor)
library(dplyr)
library(shiny)
library(shinydashboard)
```

## Load the Data: 
```{r}
netflix <- read.csv("data/netflix_titles.csv")

```

*Did copilot help you write the code above? Could anything about the prompt be improved to help Copilot understand what you want to do more accurately?*


## Lets Practice:
Explore the elements in your data: include a comment within your code chunk to prompt Copilot to use the function of your choice
```{r}
# View the first few rows of the dataset
head(netflix)

# View the structure of the dataset
str(netflix)

# Summary statistics for numerical variables
summary(netflix)

# Check for missing values
sum(is.na(netflix))

# Frequency table for categorical variables
table(netflix$column_name)  # Replace 'column_name' with the actual column name


```
*Did copilot use your preferred method to get the summary of the data? If not, how could you improve the prompt to get the desired output?*


Sort out the movies from the netflix into an new object called netflix_movies
```{r} 
netflix_movies <- netflix[netflix$type == "Movie", ]
```


Which director has the most movies on netflix?
```{r}
# Count the occurrences of each director
director_counts <- table(netflix$director)

# Convert the table into a data frame for easier manipulation
director_counts_df <- as.data.frame(director_counts)

# Rename the columns for clarity
colnames(director_counts_df) <- c("Director", "Movie_Count")

# Sort the data frame by the movie count in descending order
director_counts_df <- director_counts_df[order(-director_counts_df$Movie_Count), ]


```
*Do you see anything wrong with the table above, look at row 1. Write a prompt below to fix this.*

what is the most popular country of origin for movies?
```{r}
movies <- netflix[netflix$type == "Movie", ]

# Count the occurrences of each country of origin
country_counts <- table(movies$country)

# Find the country with the highest count
most_popular_country <- names(country_counts)[which.max(country_counts)]

# Print the result
print(paste("The most popular country of origin for movies on Netflix is:", most_popular_country))

```



Which director had the most movies by release year and remove the NA's? 
##didnt work 
```{r}
# Load the dplyr package
library(dplyr)

# Filter the dataset to include only movies and remove rows with missing director information
movies <- netflix %>%
  filter(type == "Movie" & !is.na(director))

# Group the data by release year and director, then count the number of movies for each combination
director_counts <- movies %>%
  group_by(release_year, director) %>%
  summarise(num_movies = n(), .groups = "drop")

# Find the director with the most movies for each release year
most_movies_by_year <- director_counts %>%
  group_by(release_year) %>%
  filter(num_movies == max(num_movies)) %>%
  select(release_year, director, num_movies)

# Print the result
print(most_movies_by_year)
```
*See anything else interesting about this table, look at the first director on the table. Could this be a problem and how can we edit the dataset to fix this? Try writing a prompt.*


[Insert your prompt here]
```{r}

```



Make a bar plot of the top directors with the most movies on netflix
```{r}
library(dplyr)
library(ggplot2)

# Filter the dataset to include only movies and remove rows with missing director information
movies <- netflix %>%
  filter(type == "Movie" & !is.na(director))

# Group the data by director and count the number of movies for each director
director_counts <- movies %>%
  group_by(director) %>%
  summarise(num_movies = n(), .groups = "drop")

# Select the top directors with the most movies
top_directors <- director_counts %>%
  arrange(desc(num_movies)) %>%
  top_n(10)

# Create a bar plot
ggplot(top_directors, aes(x = reorder(director, num_movies), y = num_movies)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Top Directors with the Most Movies on Netflix",
       x = "Director",
       y = "Number of Movies") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability

```
*Do you see any issues with this plot? How could we improve the prompt to get a better boxplot? Try writing a prompt.*

[Insert your prompt here]
```{r}
library(dplyr)
library(ggplot2)

# Filter the dataset to include only movies and remove rows with missing director information
movies <- netflix %>%
  filter(type == "Movie" & director != "")  # Exclude rows with empty strings in the 'director' column

# Group the data by director and count the number of movies for each director
director_counts <- movies %>%
  group_by(director) %>%
  summarise(num_movies = n(), .groups = "drop")

# Select the top directors with the most movies
top_directors <- director_counts %>%
  arrange(desc(num_movies)) %>%
  top_n(10)

# Create a bar plot
ggplot(top_directors, aes(x = reorder(director, num_movies), y = num_movies)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Top Directors with the Most Movies on Netflix",
       x = "Director",
       y = "Number of Movies") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability
```

*How about for just 2020*


```{r}
# Load the required packages
library(dplyr)
library(ggplot2)

# Filter the dataset to include only movies from the year 2020 and remove rows with missing director information
movies_2020 <- netflix %>%
  filter(type == "Movie" & release_year == 2020 & director != "")

# Group the data by director and count the number of movies for each director
director_counts_2020 <- movies_2020 %>%
  group_by(director) %>%
  summarise(num_movies = n(), .groups = "drop")

# Select the top directors with the most movies
top_directors_2020 <- director_counts_2020 %>%
  arrange(desc(num_movies)) %>%
  top_n(10)

# Create a bar plot
ggplot(top_directors_2020, aes(x = reorder(director, num_movies), y = num_movies)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  labs(title = "Top Directors with the Most Movies on Netflix in 2020",
       x = "Director",
       y = "Number of Movies") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability
```


*Take a few minutes to make your own plot(s) using prompts, edit prompts until you get a plot that you like.*

using netflix create a boxplot for the ratio of movies to TV Shows

```{r}
# Load the required package
library(dplyr)
library(ggplot2)

# Calculate the ratio of movies to TV shows
netflix_ratio <- netflix %>%
  group_by(type) %>%
  summarise(count = n()) %>%
  mutate(ratio = count / sum(count))

# Create a boxplot
ggplot(netflix_ratio, aes(x = type, y = ratio)) +
  geom_boxplot(fill = "skyblue") +
  labs(title = "Ratio of Movies to TV Shows on Netflix",
       x = "Type",
       y = "Ratio",
       fill = "") +
  theme_minimal()
```





## Lets make the top 10 directors barplot into a Shiny App: use copilot or Chatgpt
```{r}
library(shiny)
library(dplyr)
library(ggplot2)

# Define UI
ui <- fluidPage(
  titlePanel("Top Directors with the Most Movies on Netflix in 2020"),
  mainPanel(
    plotOutput("barplot")
  )
)

# Define server logic
server <- function(input, output) {
  # Filter the dataset to include only movies from the year 2020 and remove rows with missing director information
  movies_2020 <- netflix %>%
    filter(type == "Movie" & release_year == 2020 & director != "")

  # Group the data by director and count the number of movies for each director
  director_counts_2020 <- movies_2020 %>%
    group_by(director) %>%
    summarise(num_movies = n(), .groups = "drop")

  # Select the top directors with the most movies
  top_directors_2020 <- director_counts_2020 %>%
    arrange(desc(num_movies)) %>%
    top_n(10)

  # Create the bar plot
  output$barplot <- renderPlot({
    ggplot(top_directors_2020, aes(x = reorder(director, num_movies), y = num_movies)) +
      geom_bar(stat = "identity", fill = "skyblue") +
      labs(title = "Top Directors with the Most Movies on Netflix in 2020",
           x = "Director",
           y = "Number of Movies") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```

make a shiny app for the most popular director and allow for the user to interact via the year 
```{r}
library(shiny)
library(dplyr)



# Define UI
ui <- fluidPage(
  titlePanel("Top Directors by Year"),
  sidebarLayout(
    sidebarPanel(
      selectInput("year", "Select a Year:", choices = unique(netflix$release_year))
    ),
    mainPanel(
      tableOutput("top_directors")
    )
  )
)

# Define server logic
server <- function(input, output) {
  # Calculate the top 5 directors for the selected year
  top_directors <- reactive({
    movies_year <- netflix %>%
      filter(type == "Movie" & release_year == input$year & !is.na(director) & director != "") %>%
      group_by(director) %>%
      summarise(num_movies = n()) %>%
      arrange(desc(num_movies)) %>%
      slice_head(n = 5)
    return(movies_year)
  })
  
  # Display the top 5 directors in a table
  output$top_directors <- renderTable({
    top_directors()
  })
}

# Run the application
shinyApp(ui = ui, server = server)
```



*Now use ChatGPT, Copilot or previous notes to fix the code*





## That's it! Let's take a break and then move on to working on group projects.
